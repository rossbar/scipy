<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Sparse eigenvalue problems with ARPACK &mdash; SciPy v1.5.0.dev0+47ffc1e Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.0.dev0+47ffc1e',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.5.0.dev0+47ffc1e Reference Guide" href="../index.html" >
    <link rel="up" title="SciPy Tutorial" href="index.html" >
    <link rel="next" title="Compressed Sparse Graph Routines (scipy.sparse.csgraph)" href="csgraph.html" >
    <link rel="prev" title="Linear Algebra (scipy.linalg)" href="linalg.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="../_static/img/scipy_org_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">SciPy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
	
        <li class="active"><a href="../index.html">SciPy v1.5.0.dev0+47ffc1e Reference Guide</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">SciPy Tutorial</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="csgraph.html" title="Compressed Sparse Graph Routines (scipy.sparse.csgraph)"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="linalg.html" title="Linear Algebra (scipy.linalg)"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="sparse-eigenvalue-problems-with-arpack">
<h1>Sparse eigenvalue problems with ARPACK<a class="headerlink" href="#sparse-eigenvalue-problems-with-arpack" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>ARPACK <a class="footnote-reference brackets" href="#id3" id="id1">1</a> is a Fortran package which provides routines for quickly finding a few
eigenvalues/eigenvectors of large sparse matrices. In order to find these
solutions, it requires only left-multiplication by the matrix in question.
This operation is performed through a <em>reverse-communication</em> interface. The
result of this structure is that ARPACK is able to find eigenvalues and
eigenvectors of any linear function mapping a vector to a vector.</p>
<p>All of the functionality provided in ARPACK is contained within the two
high-level interfaces <a class="reference internal" href="../generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigs</span></code></a> and
<a class="reference internal" href="../generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="scipy.sparse.linalg.eigsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh</span></code></a>. <a class="reference internal" href="../generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigs</span></code></a>
provides interfaces for finding the
eigenvalues/vectors of real or complex nonsymmetric square matrices, while
<a class="reference internal" href="../generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="scipy.sparse.linalg.eigsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigsh</span></code></a> provides interfaces for real-symmetric or complex-hermitian
matrices.</p>
</div>
<div class="section" id="basic-functionality">
<h2>Basic functionality<a class="headerlink" href="#basic-functionality" title="Permalink to this headline">¶</a></h2>
<p>ARPACK can solve either standard eigenvalue problems of the form</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \lambda \mathbf{x}\]</div>
<p>or general eigenvalue problems of the form</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \lambda M \mathbf{x}.\]</div>
<p>The power of ARPACK is that it can compute only a specified subset of
eigenvalue/eigenvector pairs. This is accomplished through the keyword
<code class="docutils literal notranslate"><span class="pre">which</span></code>. The following values of <code class="docutils literal notranslate"><span class="pre">which</span></code> are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LM'</span></code> : Eigenvalues with largest magnitude (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>, <code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, largest eigenvalues in the euclidean norm of complex numbers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SM'</span></code> : Eigenvalues with smallest magnitude (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>, <code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, smallest eigenvalues in the euclidean norm of complex numbers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LR'</span></code> : Eigenvalues with largest real part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SR'</span></code> : Eigenvalues with smallest real part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LI'</span></code> : Eigenvalues with largest imaginary part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SI'</span></code> : Eigenvalues with smallest imaginary part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LA'</span></code> : Eigenvalues with largest algebraic value (<code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, largest eigenvalues inclusive of any negative sign.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SA'</span></code> : Eigenvalues with smallest algebraic value (<code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, smallest eigenvalues inclusive of any negative sign.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'BE'</span></code> : Eigenvalues from both ends of the spectrum (<code class="docutils literal notranslate"><span class="pre">eigsh</span></code>).</p></li>
</ul>
<p>Note that ARPACK is generally better at finding extremal eigenvalues, that
is, eigenvalues with large magnitudes. In particular, using <code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SM'</span></code>
may lead to slow execution time and/or anomalous results. A better approach
is to use <em>shift-invert mode</em>.</p>
</div>
<div class="section" id="shift-invert-mode">
<h2>Shift-invert mode<a class="headerlink" href="#shift-invert-mode" title="Permalink to this headline">¶</a></h2>
<p>Shift-invert mode relies on the following observation. For the generalized
eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \lambda M \mathbf{x},\]</div>
<p>it can be shown that</p>
<div class="math notranslate nohighlight">
\[(A - \sigma M)^{-1} M \mathbf{x} = \nu \mathbf{x},\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\nu = \frac{1}{\lambda - \sigma}.\]</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Imagine you’d like to find the smallest and largest eigenvalues and the
corresponding eigenvectors for a large matrix. ARPACK can handle many
forms of input: dense matrices ,such as <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> instances, sparse
matrices, such as <a class="reference internal" href="../generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="scipy.sparse.csr_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>, or a general linear operator
derived from <a class="reference internal" href="../generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a>. For this example, for
simplicity, we’ll construct a symmetric, positive-definite matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eig</span><span class="p">,</span> <span class="n">eigh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">eigsh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1">#create a symmetric matrix</span>
</pre></div>
</div>
<p>We now have a symmetric matrix <code class="docutils literal notranslate"><span class="pre">X</span></code>, with which to test the routines. First,
compute a standard eigenvalue decomposition using <code class="docutils literal notranslate"><span class="pre">eigh</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">,</span> <span class="n">evecs_all</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>As the dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> grows, this routine becomes very slow. Especially,
if only a few eigenvectors and eigenvalues are needed, <code class="docutils literal notranslate"><span class="pre">ARPACK</span></code> can be a
better option. First let’s compute the largest eigenvalues (<code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LM'</span></code>)
of <code class="docutils literal notranslate"><span class="pre">X</span></code> and compare them to the known results:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span><span class="p">,</span> <span class="n">evecs_large</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">evals_all</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
<span class="go">[29.1446102  30.05821805 31.19467646]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">evals_large</span><span class="p">)</span>
<span class="go">[29.1446102  30.05821805 31.19467646]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_large</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,</span><span class="o">-</span><span class="mi">3</span><span class="p">:]))</span>
<span class="go">array([[-1.  0.  0.],       # may vary (signs)</span>
<span class="go">       [ 0.  1.  0.],</span>
<span class="go">       [-0.  0. -1.]])</span>
</pre></div>
</div>
<p>The results are as expected. ARPACK recovers the desired eigenvalues and they
match the previously known results. Furthermore, the eigenvectors are
orthogonal, as we’d expect. Now, let’s attempt to solve for the eigenvalues
with smallest magnitude:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">)</span>
<span class="x">Traceback (most recent call last):       # may vary (convergence)</span>
<span class="x">...</span>
<span class="x">scipy.sparse.linalg.eigen.arpack.arpack.ArpackNoConvergence:</span>
<span class="go">ARPACK error -1: No convergence (1001 iterations, 0/3 eigenvectors converged)</span>
</pre></div>
</div>
<p>Oops. We see that, as mentioned above, <code class="docutils literal notranslate"><span class="pre">ARPACK</span></code> is not quite as adept at
finding small eigenvalues. There are a few ways this problem can be
addressed. We could increase the tolerance (<code class="docutils literal notranslate"><span class="pre">tol</span></code>) to lead to faster
convergence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([0.0003783, 0.00122714, 0.00715878])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span>
<span class="go">array([0.00037831, 0.00122714, 0.00715881])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_small</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 0.99999999  0.00000024 -0.00000049],    # may vary (signs)</span>
<span class="go">       [-0.00000023  0.99999999  0.00000056],</span>
<span class="go">       [ 0.00000031 -0.00000037  0.99999852]])</span>
</pre></div>
</div>
<p>This works, but we lose the precision in the results. Another option is
to increase the maximum number of iterations (<code class="docutils literal notranslate"><span class="pre">maxiter</span></code>) from 1000 to 5000:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([0.0003783, 0.00122714, 0.00715878])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span>
<span class="go">array([0.0003783, 0.00122714, 0.00715878])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_small</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 1.  0.  0.],           # may vary (signs)</span>
<span class="go">       [-0.  1.  0.],</span>
<span class="go">       [ 0.  0. -1.]])</span>
</pre></div>
</div>
<p>We get the results we’d hoped for, but the computation time is much longer.
Fortunately, <code class="docutils literal notranslate"><span class="pre">ARPACK</span></code> contains a mode that allows a quick determination of
non-external eigenvalues: <em>shift-invert mode</em>. As mentioned above, this
mode involves transforming the eigenvalue problem to an equivalent problem
with different eigenvalues. In this case, we hope to find eigenvalues near
zero, so we’ll choose <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">0</span></code>. The transformed eigenvalues will
then satisfy <span class="math notranslate nohighlight">\(\nu = 1/(\lambda - \sigma) = 1/\lambda\)</span>, so our
small eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span> become large eigenvalues <span class="math notranslate nohighlight">\(\nu\)</span>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([0.0003783, 0.00122714, 0.00715878])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span>
<span class="go">array([0.0003783, 0.00122714, 0.00715878])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_small</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 1.  0.  0.],    # may vary (signs)</span>
<span class="go">       [ 0. -1. -0.],</span>
<span class="go">       [-0. -0.  1.]])</span>
</pre></div>
</div>
<p>We get the results we were hoping for, with much less computational time.
Note that the transformation from <span class="math notranslate nohighlight">\(\nu \to \lambda\)</span> takes place
entirely in the background. The user need not worry about the details.</p>
<p>The shift-invert mode provides more than just a fast way to obtain a few
small eigenvalues. Say, you
desire to find internal eigenvalues and eigenvectors, e.g., those nearest to
<span class="math notranslate nohighlight">\(\lambda = 1\)</span>. Simply set <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">1</span></code> and ARPACK will take care of
the rest:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_mid</span><span class="p">,</span> <span class="n">evecs_mid</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">evals_all</span><span class="p">)))[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[</span><span class="n">i_sort</span><span class="p">]</span>
<span class="go">array([1.16577199, 0.85081388, 1.06642272])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_mid</span>
<span class="go">array([0.85081388, 1.06642272, 1.16577199])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_mid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,</span><span class="n">i_sort</span><span class="p">]))</span>
<span class="go">array([[-0.  1.  0.],     # may vary (signs)</span>
<span class="go">       [-0. -0.  1.],</span>
<span class="go">       [ 1.  0.  0.]]</span>
</pre></div>
</div>
<p>The eigenvalues come out in a different order, but they’re all there.
Note that the shift-invert mode requires the internal solution of a matrix
inverse. This is taken care of automatically by <code class="docutils literal notranslate"><span class="pre">eigsh</span></code> and <a class="reference internal" href="../generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigs</span></code></a>,
but the operation can also be specified by the user. See the docstring of
<a class="reference internal" href="../generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="scipy.sparse.linalg.eigsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh</span></code></a> and
<a class="reference internal" href="../generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigs</span></code></a> for details.</p>
</div>
<div class="section" id="use-of-linearoperator">
<h2>Use of LinearOperator<a class="headerlink" href="#use-of-linearoperator" title="Permalink to this headline">¶</a></h2>
<p>We consider now the case where you’d like to avoid creating a dense matrix
and use <a class="reference internal" href="../generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a> instead. Our first
linear operator applies element-wise multiplication between the input vector
and a vector <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> provided by the user to the operator itself.
This operator mimics a diagonal matrix with the elements of <span class="math notranslate nohighlight">\(\mathbf{d}\)</span>
along the main diagonal and it has the main benefit that the forward and
adjoint operations are simple element-wise multiplications other
than matrix-vector multiplications. For a diagonal matrix, we expect the
eigenvalues to be equal to the elements along the main diagonal, in this case
<span class="math notranslate nohighlight">\(\mathbf{d}\)</span>. The eigenvalues and eigenvectors obtained with <code class="docutils literal notranslate"><span class="pre">eigsh</span></code>
are compared to those obtained by using <code class="docutils literal notranslate"><span class="pre">eigh</span></code> when applied to
the dense matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Diagonal</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="n">diag</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="p">))</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">*</span><span class="n">x</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_rmatvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dop</span> <span class="o">=</span> <span class="n">Diagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">,</span> <span class="n">evecs_all</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span><span class="p">,</span> <span class="n">evecs_large</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">Dop</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LA&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mf">1e3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
<span class="go">array([1.9507754 , 2.2408932 , 2.26975462])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span>
<span class="go">array([1.9507754 , 2.2408932 , 2.26975462])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_large</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,</span><span class="o">-</span><span class="mi">3</span><span class="p">:]))</span>
<span class="go">array([[-1.  0.  0.],     # may vary (signs)</span>
<span class="go">       [-0. -1.  0.],</span>
<span class="go">       [ 0.  0. -1.]]</span>
</pre></div>
</div>
<p>In this case, we have created a quick and easy <code class="docutils literal notranslate"><span class="pre">Diagonal</span></code> operator.
The external library <a class="reference external" href="https://pylops.readthedocs.io">PyLops</a> provides
similar capabilities in the <a class="reference external" href="https://pylops.readthedocs.io/en/latest/api/generated/pylops.Diagonal.html#pylops.Diagonal">Diagonal</a> operator,
as well as several other operators.</p>
<p>Finally, we consider a linear operator that mimics the application of a
first-derivative stencil. In this case, the operator is equivalent to a real
nonsymmetric matrix. Once again, we compare the estimated eigenvalues
and eigenvectors with those from a dense matrix that applies the
same first derivative to an input signal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">FirstDerivative</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">y</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_rmatvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>        <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">21</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># take away edge effects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dop</span> <span class="o">=</span> <span class="n">FirstDerivative</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">,</span> <span class="n">evecs_all</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span><span class="p">,</span> <span class="n">evecs_large</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="n">Dop</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all_imag</span> <span class="o">=</span> <span class="n">evals_all</span><span class="o">.</span><span class="n">imag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isort_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals_all_imag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all_imag</span> <span class="o">=</span> <span class="n">evals_all_imag</span><span class="p">[</span><span class="n">isort_imag</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large_imag</span> <span class="o">=</span> <span class="n">evals_large</span><span class="o">.</span><span class="n">imag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isort_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals_large_imag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large_imag</span> <span class="o">=</span> <span class="n">evals_large_imag</span><span class="p">[</span><span class="n">isort_imag</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all_imag</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
<span class="go">array([-0.95105652, 0.95105652, -0.98768834, 0.98768834])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large_imag</span>
<span class="go">array([0.95105652, -0.95105652, 0.98768834, -0.98768834])</span>
</pre></div>
</div>
<p>Note that the eigenvalues of this operator are all imaginary. Moreover,
the keyword <code class="docutils literal notranslate"><span class="pre">which='LI'</span></code> of <a class="reference internal" href="../generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigs</span></code></a> produces
the eigenvalues with largest absolute imaginary part (both
positive and negative). Again, a more advanced implementation of the
first-derivative operator is available in the
<a class="reference external" href="https://pylops.readthedocs.io">PyLops</a> library under the name of
<a class="reference external" href="https://pylops.readthedocs.io/en/latest/api/generated/pylops.FirstDerivative.html">FirstDerivative</a>
operator.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="http://www.caam.rice.edu/software/ARPACK/">http://www.caam.rice.edu/software/ARPACK/</a></p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Sparse eigenvalue problems with ARPACK</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#basic-functionality">Basic functionality</a></li>
<li><a class="reference internal" href="#shift-invert-mode">Shift-invert mode</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#use-of-linearoperator">Use of LinearOperator</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="linalg.html"
                        title="previous chapter">Linear Algebra (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg</span></code>)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="csgraph.html"
                        title="next chapter">Compressed Sparse Graph Routines (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code>)</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on Dec 16, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.3.0.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>