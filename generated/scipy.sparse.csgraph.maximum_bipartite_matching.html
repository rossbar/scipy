<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.sparse.csgraph.maximum_bipartite_matching &mdash; SciPy v1.5.0.dev0+47ffc1e Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.0.dev0+47ffc1e',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.5.0.dev0+47ffc1e Reference Guide" href="../index.html" >
    <link rel="up" title="Compressed sparse graph routines (scipy.sparse.csgraph)" href="../sparse.csgraph.html" >
    <link rel="next" title="scipy.sparse.csgraph.structural_rank" href="scipy.sparse.csgraph.structural_rank.html" >
    <link rel="prev" title="scipy.sparse.csgraph.maximum_flow" href="scipy.sparse.csgraph.maximum_flow.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="../_static/img/scipy_org_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">SciPy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
	
        <li class="active"><a href="../index.html">SciPy v1.5.0.dev0+47ffc1e Reference Guide</a></li>
	
          <li class="active"><a href="../sparse.csgraph.html" accesskey="U">Compressed sparse graph routines (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.csgraph.structural_rank.html" title="scipy.sparse.csgraph.structural_rank"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.csgraph.maximum_flow.html" title="scipy.sparse.csgraph.maximum_flow"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-sparse-csgraph-maximum-bipartite-matching">
<h1>scipy.sparse.csgraph.maximum_bipartite_matching<a class="headerlink" href="#scipy-sparse-csgraph-maximum-bipartite-matching" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.sparse.csgraph.maximum_bipartite_matching">
<code class="sig-prename descclassname">scipy.sparse.csgraph.</code><code class="sig-name descname">maximum_bipartite_matching</code><span class="sig-paren">(</span><em class="sig-param">graph</em>, <em class="sig-param">perm_type='row'</em><span class="sig-paren">)</span><a class="headerlink" href="#scipy.sparse.csgraph.maximum_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matching of a bipartite graph whose cardinality is as least that
of any given matching of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">sparse matrix</span></dt><dd><p>Input sparse in CSR format whose rows represent one partition of the
graph and whose columns represent the other partition. An edge between
two vertices is indicated by the corresponding entry in the matrix
existing in its sparse representation.</p>
</dd>
<dt><strong>perm_type</strong><span class="classifier">str, {‘row’, ‘column’}</span></dt><dd><p>Which partition to return the matching in terms of: If <code class="docutils literal notranslate"><span class="pre">'row'</span></code>, the
function produces an array whose length is the number of columns in the
input, and whose <span class="math notranslate nohighlight">\(j\)</span>’th element is the row matched to the
<span class="math notranslate nohighlight">\(j\)</span>’th column. Conversely, if <code class="docutils literal notranslate"><span class="pre">perm_type</span></code> is <code class="docutils literal notranslate"><span class="pre">'column'</span></code>, this
returns the columns matched to each row.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">ndarray</span></dt><dd><p>A matching of the vertices in one of the two partitions. Unmatched
vertices are represented by a <code class="docutils literal notranslate"><span class="pre">-1</span></code> in the result.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements the Hopcroft–Karp algorithm <a class="reference internal" href="#rbb1bc47db749-1" id="id1">[1]</a>. Its time
complexity is <span class="math notranslate nohighlight">\(O(\lvert E \rvert \sqrt{\lvert V \rvert})\)</span>, and its
space complexity is linear in the number of rows. In practice, this
asymmetry between rows and columns means that it can be more efficient to
transpose the input if it contains more columns than rows.</p>
<p>By Konig’s theorem, the cardinality of the matching is also the number of
vertices appearing in a minimum vertex cover of the graph.</p>
<p>Note that if the sparse representation contains explicit zeros, these are
still counted as edges.</p>
<p>The implementation was changed in SciPy 1.4.0 to allow matching of general
bipartite graphs, where previous versions would assume that a perfect
matching existed. As such, code written against 1.4.0 will not necessarily
work on older versions.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbb1bc47db749-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>John E. Hopcroft and Richard M. Karp. “An n^{5 / 2} Algorithm for
Maximum Matchings in Bipartite Graphs” In: SIAM Journal of Computing
2.4 (1973), pp. 225–231. &lt;<a class="reference external" href="https://dx.doi.org/10.1137/0202019">https://dx.doi.org/10.1137/0202019</a>&gt;.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">maximum_bipartite_matching</span>
</pre></div>
</div>
<p>As a simple example, consider a bipartite graph in which the partitions
contain 2 and 3 elements respectively. Suppose that one partition contains
vertices labelled 0 and 1, and that the other partition contains vertices
labelled A, B, and C. Suppose that there are edges connecting 0 and C,
1 and A, and 1 and B. This graph would then be represented by the following
sparse matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Here, the 1s could be anything, as long as they end up being stored as
elements in the sparse matrix. We can now calculate maximum matchings as
follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">))</span>
<span class="go">[2 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">))</span>
<span class="go">[ 1 -1  0]</span>
</pre></div>
</div>
<p>The first output tells us that 1 and 2 are matched with C and A
respectively, and the second output tells us that A, B, and C are matched
with 1, nothing, and 0 respectively.</p>
<p>Note that explicit zeros are still converted to edges. This means that a
different way to represent the above graph is by using the CSR structure
directly as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indptr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">))</span>
<span class="go">[2 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">))</span>
<span class="go">[ 1 -1  0]</span>
</pre></div>
</div>
<p>When one or both of the partitions are empty, the matching is empty as
well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">))</span>
<span class="go">[-1 -1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>When the input matrix is square, and the graph is known to admit a perfect
matching, i.e. a matching with the property that every vertex in the graph
belongs to some edge in the matching, then one can view the output as the
permutation of rows (or columns) turning the input matrix into one with the
property that all diagonal elements are non-empty:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perm</span> <span class="o">=</span> <span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
<span class="go">[[1 0 0 1]</span>
<span class="go"> [0 1 2 0]</span>
<span class="go"> [0 1 3 0]</span>
<span class="go"> [2 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.sparse.csgraph.maximum_flow.html"
                        title="previous chapter">scipy.sparse.csgraph.maximum_flow</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.sparse.csgraph.structural_rank.html"
                        title="next chapter">scipy.sparse.csgraph.structural_rank</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on Dec 16, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.3.0.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>