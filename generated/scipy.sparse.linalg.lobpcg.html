<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.sparse.linalg.lobpcg &mdash; SciPy v1.5.0.dev0+47ffc1e Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.0.dev0+47ffc1e',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.5.0.dev0+47ffc1e Reference Guide" href="../index.html" >
    <link rel="up" title="Sparse linear algebra (scipy.sparse.linalg)" href="../sparse.linalg.html" >
    <link rel="next" title="scipy.sparse.linalg.svds" href="scipy.sparse.linalg.svds.html" >
    <link rel="prev" title="scipy.sparse.linalg.eigsh" href="scipy.sparse.linalg.eigsh.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="../_static/img/scipy_org_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">SciPy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
	
        <li class="active"><a href="../index.html">SciPy v1.5.0.dev0+47ffc1e Reference Guide</a></li>
	
          <li class="active"><a href="../sparse.linalg.html" accesskey="U">Sparse linear algebra (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.linalg</span></code>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.linalg.svds.html" title="scipy.sparse.linalg.svds"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.linalg.eigsh.html" title="scipy.sparse.linalg.eigsh"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-sparse-linalg-lobpcg">
<h1>scipy.sparse.linalg.lobpcg<a class="headerlink" href="#scipy-sparse-linalg-lobpcg" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.sparse.linalg.lobpcg">
<code class="sig-prename descclassname">scipy.sparse.linalg.</code><code class="sig-name descname">lobpcg</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">X</em>, <em class="sig-param">B=None</em>, <em class="sig-param">M=None</em>, <em class="sig-param">Y=None</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">maxiter=None</em>, <em class="sig-param">largest=True</em>, <em class="sig-param">verbosityLevel=0</em>, <em class="sig-param">retLambdaHistory=False</em>, <em class="sig-param">retResidualNormsHistory=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scipy/scipy/blob/47ffc1e/scipy/sparse/linalg/eigen/lobpcg/lobpcg.py#L128-L711"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scipy.sparse.linalg.lobpcg" title="Permalink to this definition">¶</a></dt>
<dd><p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">{sparse matrix, dense matrix, LinearOperator}</span></dt><dd><p>The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the “stiffness matrix”.</p>
</dd>
<dt><strong>X</strong><span class="classifier">ndarray, float32 or float64</span></dt><dd><p>Initial approximation to the <code class="docutils literal notranslate"><span class="pre">k</span></code> eigenvectors (non-sparse). If <em class="xref py py-obj">A</em>
has <code class="docutils literal notranslate"><span class="pre">shape=(n,n)</span></code> then <em class="xref py py-obj">X</em> should have shape <code class="docutils literal notranslate"><span class="pre">shape=(n,k)</span></code>.</p>
</dd>
<dt><strong>B</strong><span class="classifier">{dense matrix, sparse matrix, LinearOperator}, optional</span></dt><dd><p>The right hand side operator in a generalized eigenproblem.
By default, <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">Identity</span></code>.  Often called the “mass matrix”.</p>
</dd>
<dt><strong>M</strong><span class="classifier">{dense matrix, sparse matrix, LinearOperator}, optional</span></dt><dd><p>Preconditioner to <em class="xref py py-obj">A</em>; by default <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">Identity</span></code>.
<em class="xref py py-obj">M</em> should approximate the inverse of <em class="xref py py-obj">A</em>.</p>
</dd>
<dt><strong>Y</strong><span class="classifier">ndarray, float32 or float64, optional</span></dt><dd><p>n-by-sizeY matrix of constraints (non-sparse), sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">scalar, optional</span></dt><dd><p>Solver tolerance (stopping criterion).
The default is <code class="docutils literal notranslate"><span class="pre">tol=n*sqrt(eps)</span></code>.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations.  The default is <code class="docutils literal notranslate"><span class="pre">maxiter</span> <span class="pre">=</span> <span class="pre">20</span></code>.</p>
</dd>
<dt><strong>largest</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, solve for the largest eigenvalues, otherwise the smallest.</p>
</dd>
<dt><strong>verbosityLevel</strong><span class="classifier">int, optional</span></dt><dd><p>Controls solver output.  The default is <code class="docutils literal notranslate"><span class="pre">verbosityLevel=0</span></code>.</p>
</dd>
<dt><strong>retLambdaHistory</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return eigenvalue history.  Default is False.</p>
</dd>
<dt><strong>retResidualNormsHistory</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return history of residual norms.  Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>Array of <code class="docutils literal notranslate"><span class="pre">k</span></code> eigenvalues</p>
</dd>
<dt><strong>v</strong><span class="classifier">ndarray</span></dt><dd><p>An array of <code class="docutils literal notranslate"><span class="pre">k</span></code> eigenvectors.  <em class="xref py py-obj">v</em> has the same shape as <em class="xref py py-obj">X</em>.</p>
</dd>
<dt><strong>lambdas</strong><span class="classifier">list of ndarray, optional</span></dt><dd><p>The eigenvalue history, if <em class="xref py py-obj">retLambdaHistory</em> is True.</p>
</dd>
<dt><strong>rnorms</strong><span class="classifier">list of ndarray, optional</span></dt><dd><p>The history of residual norms, if <em class="xref py py-obj">retResidualNormsHistory</em> is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">retLambdaHistory</span></code> and <code class="docutils literal notranslate"><span class="pre">retResidualNormsHistory</span></code> are True,
the return tuple has the following format
<code class="docutils literal notranslate"><span class="pre">(lambda,</span> <span class="pre">V,</span> <span class="pre">lambda</span> <span class="pre">history,</span> <span class="pre">residual</span> <span class="pre">norms</span> <span class="pre">history)</span></code>.</p>
<p>In the following <code class="docutils literal notranslate"><span class="pre">n</span></code> denotes the matrix size and <code class="docutils literal notranslate"><span class="pre">m</span></code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size <code class="docutils literal notranslate"><span class="pre">3m</span></code> on every
iteration by calling the “standard” dense eigensolver, so if <code class="docutils literal notranslate"><span class="pre">m</span></code> is not
small enough compared to <code class="docutils literal notranslate"><span class="pre">n</span></code>, it does not make sense to call the LOBPCG
code, but rather one should use the “standard” eigensolver, e.g. numpy or
scipy function in this case.
If one calls the LOBPCG algorithm for <code class="docutils literal notranslate"><span class="pre">5m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, it will most likely break
internally, so the code tries to call the standard function instead.</p>
<p>It is not that <code class="docutils literal notranslate"><span class="pre">n</span></code> should be large for the LOBPCG to work, but rather the
ratio <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">/</span> <span class="pre">m</span></code> should be large. It you call LOBPCG with <code class="docutils literal notranslate"><span class="pre">m=1</span></code>
and <code class="docutils literal notranslate"><span class="pre">n=10</span></code>, it works though <code class="docutils literal notranslate"><span class="pre">n</span></code> is small. The method is intended
for extremely large <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">/</span> <span class="pre">m</span></code>, see e.g., reference [28] in
<a class="reference external" href="https://arxiv.org/abs/0705.2626">https://arxiv.org/abs/0705.2626</a></p>
<p>The convergence speed depends basically on two factors:</p>
<ol class="arabic simple">
<li><p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code class="docutils literal notranslate"><span class="pre">m</span></code> to make this better.</p></li>
<li><p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code class="docutils literal notranslate"><span class="pre">n</span></code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for <em class="xref py py-obj">A</em>, which is easy to code since A is tridiagonal.</p></li>
</ol>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbbbc6164e7a5-1"><span class="brackets">1</span></dt>
<dd><p>A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. <a class="reference external" href="http://dx.doi.org/10.1137/S1064827500366124">http://dx.doi.org/10.1137/S1064827500366124</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-2"><span class="brackets">2</span></dt>
<dd><p>A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. <a class="reference external" href="https://arxiv.org/abs/0705.2626">https://arxiv.org/abs/0705.2626</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-3"><span class="brackets">3</span></dt>
<dd><p>A. V. Knyazev’s C and MATLAB implementations:
<a class="reference external" href="https://bitbucket.org/joseroman/blopex">https://bitbucket.org/joseroman/blopex</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Solve <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">x</span></code> with constraints and preconditioning.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">spdiags</span><span class="p">,</span> <span class="n">issparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">lobpcg</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[  1.,   0.,   0., ...,   0.,   0.,   0.],</span>
<span class="go">       [  0.,   2.,   0., ...,   0.,   0.,   0.],</span>
<span class="go">       [  0.,   0.,   3., ...,   0.,   0.,   0.],</span>
<span class="go">       ...,</span>
<span class="go">       [  0.,   0.,   0., ...,  98.,   0.,   0.],</span>
<span class="go">       [  0.,   0.,   0., ...,   0.,  99.,   0.],</span>
<span class="go">       [  0.,   0.,   0., ...,   0.,   0., 100.]])</span>
</pre></div>
</div>
<p>Constraints:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Preconditioner in the inverse of A in this example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invA</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="n">vals</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>The preconditiner must be defined by a function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">precond</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">invA</span> <span class="o">@</span> <span class="n">x</span>
</pre></div>
</div>
<p>The argument x of the preconditioner function is a matrix inside <a class="reference internal" href="#scipy.sparse.linalg.lobpcg" title="scipy.sparse.linalg.lobpcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lobpcg</span></code></a>,
thus the use of matrix-matrix product <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>.</p>
<p>The preconditioner function is passed to lobpcg as a <a class="reference internal" href="scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearOperator</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">matvec</span><span class="o">=</span><span class="n">precond</span><span class="p">,</span> <span class="n">matmat</span><span class="o">=</span><span class="n">precond</span><span class="p">,</span>
<span class="gp">... </span>                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us now solve the eigenvalue problem for the matrix A:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lobpcg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span>
<span class="go">array([4., 5., 6.])</span>
</pre></div>
</div>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
</dd></dl>

</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.sparse.linalg.eigsh.html"
                        title="previous chapter">scipy.sparse.linalg.eigsh</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.sparse.linalg.svds.html"
                        title="next chapter">scipy.sparse.linalg.svds</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on Dec 16, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.3.0.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>