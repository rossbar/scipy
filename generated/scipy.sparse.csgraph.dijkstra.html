<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.sparse.csgraph.dijkstra &mdash; SciPy v1.5.0.dev0+47ffc1e Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.0.dev0+47ffc1e',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.5.0.dev0+47ffc1e Reference Guide" href="../index.html" >
    <link rel="up" title="Compressed sparse graph routines (scipy.sparse.csgraph)" href="../sparse.csgraph.html" >
    <link rel="next" title="scipy.sparse.csgraph.floyd_warshall" href="scipy.sparse.csgraph.floyd_warshall.html" >
    <link rel="prev" title="scipy.sparse.csgraph.shortest_path" href="scipy.sparse.csgraph.shortest_path.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="../_static/img/scipy_org_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">SciPy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
	
        <li class="active"><a href="../index.html">SciPy v1.5.0.dev0+47ffc1e Reference Guide</a></li>
	
          <li class="active"><a href="../sparse.csgraph.html" accesskey="U">Compressed sparse graph routines (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.csgraph.floyd_warshall.html" title="scipy.sparse.csgraph.floyd_warshall"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.csgraph.shortest_path.html" title="scipy.sparse.csgraph.shortest_path"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-sparse-csgraph-dijkstra">
<h1>scipy.sparse.csgraph.dijkstra<a class="headerlink" href="#scipy-sparse-csgraph-dijkstra" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.sparse.csgraph.dijkstra">
<code class="sig-prename descclassname">scipy.sparse.csgraph.</code><code class="sig-name descname">dijkstra</code><span class="sig-paren">(</span><em class="sig-param">csgraph</em>, <em class="sig-param">directed=True</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">return_predecessors=False</em>, <em class="sig-param">unweighted=False</em>, <em class="sig-param">limit=np.inf</em>, <em class="sig-param">min_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scipy.sparse.csgraph.dijkstra" title="Permalink to this definition">¶</a></dt>
<dd><p>Dijkstra algorithm using Fibonacci Heaps</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.11.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>csgraph</strong><span class="classifier">array, matrix, or sparse matrix, 2 dimensions</span></dt><dd><p>The N x N array of non-negative distances representing the input graph.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), then find the shortest path on a directed graph:
only move from point i to point j along paths csgraph[i, j] and from
point j to i along paths csgraph[j, i].
If False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j or j to i along either
csgraph[i, j] or csgraph[j, i].</p>
</dd>
<dt><strong>indices</strong><span class="classifier">array_like or int, optional</span></dt><dd><p>if specified, only compute the paths from the points at the given
indices.</p>
</dd>
<dt><strong>return_predecessors</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return the size (N, N) predecesor matrix</p>
</dd>
<dt><strong>unweighted</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, then find unweighted distances.  That is, rather than finding
the path between each point such that the sum of weights is minimized,
find the path such that the number of edges is minimized.</p>
</dd>
<dt><strong>limit</strong><span class="classifier">float, optional</span></dt><dd><p>The maximum distance to calculate, must be &gt;= 0. Using a smaller limit
will decrease computation time by aborting calculations between pairs
that are separated by a distance &gt; limit. For such pairs, the distance
will be equal to np.inf (i.e., not connected).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.14.0.</span></p>
</div>
</dd>
<dt><strong>min_only</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default), for every node in the graph, find the shortest path
from every node in indices.
If True, for every node in the graph, find the shortest path from any
of the nodes in indices (which can be substantially faster).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist_matrix</strong><span class="classifier">ndarray, shape ([n_indices, ]n_nodes,)</span></dt><dd><p>The matrix of distances between graph nodes. If min_only=False,
dist_matrix has shape (n_indices, n_nodes) and dist_matrix[i, j]
gives the shortest distance from point i to point j along the graph.
If min_only=True, dist_matrix has shape (n_nodes,) and contains for
a given node the shortest path to that node from any of the nodes
in indices.</p>
</dd>
<dt><strong>predecessors</strong><span class="classifier">ndarray, shape ([n_indices, ]n_nodes,)</span></dt><dd><p>If min_only=False, this has shape (n_indices, n_nodes),
otherwise it has shape (n_nodes,).
Returned only if return_predecessors == True.
The matrix of predecessors, which can be used to reconstruct
the shortest paths.  Row i of the predecessor matrix contains
information on the shortest paths from point i: each entry
predecessors[i, j] gives the index of the previous node in the
path from point i to point j.  If no path exists between point
i and j, then predecessors[i, j] = -9999</p>
</dd>
<dt><strong>sources</strong><span class="classifier">ndarray, shape (n_nodes,)</span></dt><dd><p>Returned only if min_only=True and return_predecessors=True.
Contains the index of the source which had the shortest path
to each target.  If no path exists within the limit,
this will contain -9999.  The value at the indices passed
will be equal to that index (i.e. the fastest way to reach
node i, is to start on node i).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As currently implemented, Dijkstra’s algorithm does not work for
graphs with direction-dependent distances when directed == False.
i.e., if csgraph[i,j] and csgraph[j,i] are not equal and
both are nonzero, setting directed=False will not yield the correct
result.</p>
<p>Also, this routine does not work for graphs with negative
distances.  Negative distances can lead to infinite cycles that must
be handled by specialized algorithms such as Bellman-Ford’s algorithm
or Johnson’s algorithm.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">dijkstra</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="go">  (0, 1)    1</span>
<span class="go">  (0, 2)    2</span>
<span class="go">  (1, 3)    1</span>
<span class="go">  (2, 3)    3</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dist_matrix</span><span class="p">,</span> <span class="n">predecessors</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_matrix</span>
<span class="go">array([ 0.,  1.,  2.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">predecessors</span>
<span class="go">array([-9999,     0,     0,     1], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.sparse.csgraph.shortest_path.html"
                        title="previous chapter">scipy.sparse.csgraph.shortest_path</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.sparse.csgraph.floyd_warshall.html"
                        title="next chapter">scipy.sparse.csgraph.floyd_warshall</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on Dec 16, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.3.0.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>