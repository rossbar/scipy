<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.optimize.least_squares &mdash; SciPy v1.5.0.dev0+47ffc1e Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.0.dev0+47ffc1e',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.5.0.dev0+47ffc1e Reference Guide" href="../index.html" >
    <link rel="up" title="Optimization and root finding (scipy.optimize)" href="../optimize.html" >
    <link rel="next" title="scipy.optimize.nnls" href="scipy.optimize.nnls.html" >
    <link rel="prev" title="scipy.optimize.dual_annealing" href="scipy.optimize.dual_annealing.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="../_static/img/scipy_org_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">SciPy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
	
        <li class="active"><a href="../index.html">SciPy v1.5.0.dev0+47ffc1e Reference Guide</a></li>
	
          <li class="active"><a href="../optimize.html" accesskey="U">Optimization and root finding (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.optimize.nnls.html" title="scipy.optimize.nnls"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.optimize.dual_annealing.html" title="scipy.optimize.dual_annealing"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-optimize-least-squares">
<h1>scipy.optimize.least_squares<a class="headerlink" href="#scipy-optimize-least-squares" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="scipy.optimize.least_squares">
<code class="sig-prename descclassname">scipy.optimize.</code><code class="sig-name descname">least_squares</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">jac='2-point'</em>, <em class="sig-param">bounds=(-inf</em>, <em class="sig-param">inf)</em>, <em class="sig-param">method='trf'</em>, <em class="sig-param">ftol=1e-08</em>, <em class="sig-param">xtol=1e-08</em>, <em class="sig-param">gtol=1e-08</em>, <em class="sig-param">x_scale=1.0</em>, <em class="sig-param">loss='linear'</em>, <em class="sig-param">f_scale=1.0</em>, <em class="sig-param">diff_step=None</em>, <em class="sig-param">tr_solver=None</em>, <em class="sig-param">tr_options={}</em>, <em class="sig-param">jac_sparsity=None</em>, <em class="sig-param">max_nfev=None</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">kwargs={}</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scipy/scipy/blob/47ffc1e/scipy/optimize/_lsq/least_squares.py#L240-L940"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scipy.optimize.least_squares" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a nonlinear least-squares problem with bounds on the variables.</p>
<p>Given the residuals f(x) (an m-D real function of n real
variables) and the loss function rho(s) (a scalar function), <a class="reference internal" href="#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">least_squares</span></code></a>
finds a local minimum of the cost function F(x):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">minimize</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="n">f_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">lb</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">ub</span>
</pre></div>
</div>
<p>The purpose of the loss function rho(s) is to reduce the influence of
outliers on the solution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fun</strong><span class="classifier">callable</span></dt><dd><p>Function which computes the vector of residuals, with the signature
<code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>, i.e., the minimization proceeds with
respect to its first argument. The argument <code class="docutils literal notranslate"><span class="pre">x</span></code> passed to this
function is an ndarray of shape (n,) (never a scalar, even for n=1).
It must return a 1-D array_like of shape (m,) or a scalar. If the
argument <code class="docutils literal notranslate"><span class="pre">x</span></code> is complex or the function <code class="docutils literal notranslate"><span class="pre">fun</span></code> returns complex
residuals, it must be wrapped in a real function of real arguments,
as shown at the end of the Examples section.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">array_like with shape (n,) or float</span></dt><dd><p>Initial guess on independent variables. If float, it will be treated
as a 1-D array with one element.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">{‘2-point’, ‘3-point’, ‘cs’, callable}, optional</span></dt><dd><p>Method of computing the Jacobian matrix (an m-by-n matrix, where
element (i, j) is the partial derivative of f[i] with respect to
x[j]). The keywords select a finite difference scheme for numerical
estimation. The scheme ‘3-point’ is more accurate, but requires
twice as many operations as ‘2-point’ (default). The scheme ‘cs’
uses complex steps, and while potentially the most accurate, it is
applicable only when <em class="xref py py-obj">fun</em> correctly handles complex inputs and
can be analytically continued to the complex plane. Method ‘lm’
always uses the ‘2-point’ scheme. If callable, it is used as
<code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and should return a good approximation
(or the exact value) for the Jacobian as an array_like (np.atleast_2d
is applied), a sparse matrix or a <a class="reference internal" href="scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a>.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">2-tuple of array_like, optional</span></dt><dd><p>Lower and upper bounds on independent variables. Defaults to no bounds.
Each array must match the size of <em class="xref py py-obj">x0</em> or be a scalar, in the latter
case a bound will be the same for all variables. Use <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> with
an appropriate sign to disable bounds on all or some variables.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘trf’, ‘dogbox’, ‘lm’}, optional</span></dt><dd><p>Algorithm to perform minimization.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘trf’ : Trust Region Reflective algorithm, particularly suitable
for large sparse problems with bounds. Generally robust method.</p></li>
<li><p>‘dogbox’ : dogleg algorithm with rectangular trust regions,
typical use case is small problems with bounds. Not recommended
for problems with rank-deficient Jacobian.</p></li>
<li><p>‘lm’ : Levenberg-Marquardt algorithm as implemented in MINPACK.
Doesn’t handle bounds and sparse Jacobians. Usually the most
efficient method for small unconstrained problems.</p></li>
</ul>
</div></blockquote>
<p>Default is ‘trf’. See Notes for more information.</p>
</dd>
<dt><strong>ftol</strong><span class="classifier">float or None, optional</span></dt><dd><p>Tolerance for termination by the change of the cost function. Default
is 1e-8. The optimization process is stopped when <code class="docutils literal notranslate"><span class="pre">dF</span> <span class="pre">&lt;</span> <span class="pre">ftol</span> <span class="pre">*</span> <span class="pre">F</span></code>,
and there was an adequate agreement between a local quadratic model and
the true model in the last step. If None, the termination by this
condition is disabled.</p>
</dd>
<dt><strong>xtol</strong><span class="classifier">float or None, optional</span></dt><dd><p>Tolerance for termination by the change of the independent variables.
Default is 1e-8. The exact condition depends on the <em class="xref py py-obj">method</em> used:</p>
<blockquote>
<div><ul class="simple">
<li><p>For ‘trf’ and ‘dogbox’ : <code class="docutils literal notranslate"><span class="pre">norm(dx)</span> <span class="pre">&lt;</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">(xtol</span> <span class="pre">+</span> <span class="pre">norm(x))</span></code>.</p></li>
<li><p>For ‘lm’ : <code class="docutils literal notranslate"><span class="pre">Delta</span> <span class="pre">&lt;</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">norm(xs)</span></code>, where <code class="docutils literal notranslate"><span class="pre">Delta</span></code> is
a trust-region radius and <code class="docutils literal notranslate"><span class="pre">xs</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>
scaled according to <em class="xref py py-obj">x_scale</em> parameter (see below).</p></li>
</ul>
</div></blockquote>
<p>If None, the termination by this condition is disabled.</p>
</dd>
<dt><strong>gtol</strong><span class="classifier">float or None, optional</span></dt><dd><p>Tolerance for termination by the norm of the gradient. Default is 1e-8.
The exact condition depends on a <em class="xref py py-obj">method</em> used:</p>
<blockquote>
<div><ul class="simple">
<li><p>For ‘trf’ : <code class="docutils literal notranslate"><span class="pre">norm(g_scaled,</span> <span class="pre">ord=np.inf)</span> <span class="pre">&lt;</span> <span class="pre">gtol</span></code>, where
<code class="docutils literal notranslate"><span class="pre">g_scaled</span></code> is the value of the gradient scaled to account for
the presence of the bounds <a class="reference internal" href="#r20fc1df64af7-stir" id="id1">[STIR]</a>.</p></li>
<li><p>For ‘dogbox’ : <code class="docutils literal notranslate"><span class="pre">norm(g_free,</span> <span class="pre">ord=np.inf)</span> <span class="pre">&lt;</span> <span class="pre">gtol</span></code>, where
<code class="docutils literal notranslate"><span class="pre">g_free</span></code> is the gradient with respect to the variables which
are not in the optimal state on the boundary.</p></li>
<li><p>For ‘lm’ : the maximum absolute value of the cosine of angles
between columns of the Jacobian and the residual vector is less
than <em class="xref py py-obj">gtol</em>, or the residual vector is zero.</p></li>
</ul>
</div></blockquote>
<p>If None, the termination by this condition is disabled.</p>
</dd>
<dt><strong>x_scale</strong><span class="classifier">array_like or ‘jac’, optional</span></dt><dd><p>Characteristic scale of each variable. Setting <em class="xref py py-obj">x_scale</em> is equivalent
to reformulating the problem in scaled variables <code class="docutils literal notranslate"><span class="pre">xs</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">/</span> <span class="pre">x_scale</span></code>.
An alternative view is that the size of a trust region along jth
dimension is proportional to <code class="docutils literal notranslate"><span class="pre">x_scale[j]</span></code>. Improved convergence may
be achieved by setting <em class="xref py py-obj">x_scale</em> such that a step of a given size
along any of the scaled variables has a similar effect on the cost
function. If set to ‘jac’, the scale is iteratively updated using the
inverse norms of the columns of the Jacobian matrix (as described in
<a class="reference internal" href="#r20fc1df64af7-jjmore" id="id2">[JJMore]</a>).</p>
</dd>
<dt><strong>loss</strong><span class="classifier">str or callable, optional</span></dt><dd><p>Determines the loss function. The following keyword values are allowed:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘linear’ (default) : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">z</span></code>. Gives a standard
least-squares problem.</p></li>
<li><p>‘soft_l1’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">((1</span> <span class="pre">+</span> <span class="pre">z)**0.5</span> <span class="pre">-</span> <span class="pre">1)</span></code>. The smooth
approximation of l1 (absolute value) loss. Usually a good
choice for robust least squares.</p></li>
<li><p>‘huber’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">if</span> <span class="pre">z</span> <span class="pre">&lt;=</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">2*z**0.5</span> <span class="pre">-</span> <span class="pre">1</span></code>. Works
similarly to ‘soft_l1’.</p></li>
<li><p>‘cauchy’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">ln(1</span> <span class="pre">+</span> <span class="pre">z)</span></code>. Severely weakens outliers
influence, but may cause difficulties in optimization process.</p></li>
<li><p>‘arctan’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">arctan(z)</span></code>. Limits a maximum loss on
a single residual, has properties similar to ‘cauchy’.</p></li>
</ul>
</div></blockquote>
<p>If callable, it must take a 1-D ndarray <code class="docutils literal notranslate"><span class="pre">z=f**2</span></code> and return an
array_like with shape (3, m) where row 0 contains function values,
row 1 contains first derivatives and row 2 contains second
derivatives. Method ‘lm’ supports only ‘linear’ loss.</p>
</dd>
<dt><strong>f_scale</strong><span class="classifier">float, optional</span></dt><dd><p>Value of soft margin between inlier and outlier residuals, default
is 1.0. The loss function is evaluated as follows
<code class="docutils literal notranslate"><span class="pre">rho_(f**2)</span> <span class="pre">=</span> <span class="pre">C**2</span> <span class="pre">*</span> <span class="pre">rho(f**2</span> <span class="pre">/</span> <span class="pre">C**2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is <em class="xref py py-obj">f_scale</em>,
and <code class="docutils literal notranslate"><span class="pre">rho</span></code> is determined by <em class="xref py py-obj">loss</em> parameter. This parameter has
no effect with <code class="docutils literal notranslate"><span class="pre">loss='linear'</span></code>, but for other <em class="xref py py-obj">loss</em> values it is
of crucial importance.</p>
</dd>
<dt><strong>max_nfev</strong><span class="classifier">None or int, optional</span></dt><dd><p>Maximum number of function evaluations before the termination.
If None (default), the value is chosen automatically:</p>
<blockquote>
<div><ul class="simple">
<li><p>For ‘trf’ and ‘dogbox’ : 100 * n.</p></li>
<li><p>For ‘lm’ :  100 * n if <em class="xref py py-obj">jac</em> is callable and 100 * n * (n + 1)
otherwise (because ‘lm’ counts function calls in Jacobian
estimation).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>diff_step</strong><span class="classifier">None or array_like, optional</span></dt><dd><p>Determines the relative step size for the finite difference
approximation of the Jacobian. The actual step is computed as
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">diff_step</span></code>. If None (default), then <em class="xref py py-obj">diff_step</em> is taken to be
a conventional “optimal” power of machine epsilon for the finite
difference scheme used <a class="reference internal" href="#r20fc1df64af7-nr" id="id3">[NR]</a>.</p>
</dd>
<dt><strong>tr_solver</strong><span class="classifier">{None, ‘exact’, ‘lsmr’}, optional</span></dt><dd><p>Method for solving trust-region subproblems, relevant only for ‘trf’
and ‘dogbox’ methods.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘exact’ is suitable for not very large problems with dense
Jacobian matrices. The computational complexity per iteration is
comparable to a singular value decomposition of the Jacobian
matrix.</p></li>
<li><p>‘lsmr’ is suitable for problems with sparse and large Jacobian
matrices. It uses the iterative procedure
<a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a> for finding a solution of a linear
least-squares problem and only requires matrix-vector product
evaluations.</p></li>
</ul>
</div></blockquote>
<p>If None (default), the solver is chosen based on the type of Jacobian
returned on the first iteration.</p>
</dd>
<dt><strong>tr_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword options passed to trust-region solver.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tr_solver='exact'</span></code>: <em class="xref py py-obj">tr_options</em> are ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tr_solver='lsmr'</span></code>: options for <a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a>.
Additionally,  <code class="docutils literal notranslate"><span class="pre">method='trf'</span></code> supports  ‘regularize’ option
(bool, default is True), which adds a regularization term to the
normal equation, which improves convergence if the Jacobian is
rank-deficient <a class="reference internal" href="#r20fc1df64af7-byrd" id="id4">[Byrd]</a> (eq. 3.4).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac_sparsity</strong><span class="classifier">{None, array_like, sparse matrix}, optional</span></dt><dd><p>Defines the sparsity structure of the Jacobian matrix for finite
difference estimation, its shape must be (m, n). If the Jacobian has
only few non-zero elements in <em>each</em> row, providing the sparsity
structure will greatly speed up the computations <a class="reference internal" href="#r20fc1df64af7-curtis" id="id5">[Curtis]</a>. A zero
entry means that a corresponding element in the Jacobian is identically
zero. If provided, forces the use of ‘lsmr’ trust-region solver.
If None (default), then dense differencing will be used. Has no effect
for ‘lm’ method.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">{0, 1, 2}, optional</span></dt><dd><p>Level of algorithm’s verbosity:</p>
<blockquote>
<div><ul class="simple">
<li><p>0 (default) : work silently.</p></li>
<li><p>1 : display a termination report.</p></li>
<li><p>2 : display progress during iterations (not supported by ‘lm’
method).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>args, kwargs</strong><span class="classifier">tuple and dict, optional</span></dt><dd><p>Additional arguments passed to <em class="xref py py-obj">fun</em> and <em class="xref py py-obj">jac</em>. Both empty by default.
The calling signature is <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and the same for
<em class="xref py py-obj">jac</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><a class="reference internal" href="scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult" title="scipy.optimize.OptimizeResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimizeResult</span></code></a> with the following fields defined:</dt><dd></dd>
<dt><strong>x</strong><span class="classifier">ndarray, shape (n,)</span></dt><dd><p>Solution found.</p>
</dd>
<dt><strong>cost</strong><span class="classifier">float</span></dt><dd><p>Value of the cost function at the solution.</p>
</dd>
<dt><strong>fun</strong><span class="classifier">ndarray, shape (m,)</span></dt><dd><p>Vector of residuals at the solution.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">ndarray, sparse matrix or LinearOperator, shape (m, n)</span></dt><dd><p>Modified Jacobian matrix at the solution, in the sense that J^T J
is a Gauss-Newton approximation of the Hessian of the cost function.
The type is the same as the one used by the algorithm.</p>
</dd>
<dt><strong>grad</strong><span class="classifier">ndarray, shape (m,)</span></dt><dd><p>Gradient of the cost function at the solution.</p>
</dd>
<dt><strong>optimality</strong><span class="classifier">float</span></dt><dd><p>First-order optimality measure. In unconstrained problems, it is always
the uniform norm of the gradient. In constrained problems, it is the
quantity which was compared with <em class="xref py py-obj">gtol</em> during iterations.</p>
</dd>
<dt><strong>active_mask</strong><span class="classifier">ndarray of int, shape (n,)</span></dt><dd><p>Each component shows whether a corresponding constraint is active
(that is, whether a variable is at the bound):</p>
<blockquote>
<div><ul class="simple">
<li><p>0 : a constraint is not active.</p></li>
<li><p>-1 : a lower bound is active.</p></li>
<li><p>1 : an upper bound is active.</p></li>
</ul>
</div></blockquote>
<p>Might be somewhat arbitrary for ‘trf’ method as it generates a sequence
of strictly feasible iterates and <em class="xref py py-obj">active_mask</em> is determined within a
tolerance threshold.</p>
</dd>
<dt><strong>nfev</strong><span class="classifier">int</span></dt><dd><p>Number of function evaluations done. Methods ‘trf’ and ‘dogbox’ do not
count function calls for numerical Jacobian approximation, as opposed
to ‘lm’ method.</p>
</dd>
<dt><strong>njev</strong><span class="classifier">int or None</span></dt><dd><p>Number of Jacobian evaluations done. If numerical Jacobian
approximation is used in ‘lm’ method, it is set to None.</p>
</dd>
<dt><strong>status</strong><span class="classifier">int</span></dt><dd><p>The reason for algorithm termination:</p>
<blockquote>
<div><ul class="simple">
<li><p>-1 : improper input parameters status returned from MINPACK.</p></li>
<li><p>0 : the maximum number of function evaluations is exceeded.</p></li>
<li><p>1 : <em class="xref py py-obj">gtol</em> termination condition is satisfied.</p></li>
<li><p>2 : <em class="xref py py-obj">ftol</em> termination condition is satisfied.</p></li>
<li><p>3 : <em class="xref py py-obj">xtol</em> termination condition is satisfied.</p></li>
<li><p>4 : Both <em class="xref py py-obj">ftol</em> and <em class="xref py py-obj">xtol</em> termination conditions are satisfied.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>message</strong><span class="classifier">str</span></dt><dd><p>Verbal description of the termination reason.</p>
</dd>
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True if one of the convergence criteria is satisfied (<em class="xref py py-obj">status</em> &gt; 0).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="scipy.optimize.leastsq.html#scipy.optimize.leastsq" title="scipy.optimize.leastsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">leastsq</span></code></a></dt><dd><p>A legacy wrapper for the MINPACK implementation of the Levenberg-Marquadt algorithm.</p>
</dd>
<dt><a class="reference internal" href="scipy.optimize.curve_fit.html#scipy.optimize.curve_fit" title="scipy.optimize.curve_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">curve_fit</span></code></a></dt><dd><p>Least-squares minimization applied to a curve-fitting problem.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Method ‘lm’ (Levenberg-Marquardt) calls a wrapper over least-squares
algorithms implemented in MINPACK (lmder, lmdif). It runs the
Levenberg-Marquardt algorithm formulated as a trust-region type algorithm.
The implementation is based on paper <a class="reference internal" href="#r20fc1df64af7-jjmore" id="id6">[JJMore]</a>, it is very robust and
efficient with a lot of smart tricks. It should be your first choice
for unconstrained problems. Note that it doesn’t support bounds. Also,
it doesn’t work when m &lt; n.</p>
<p>Method ‘trf’ (Trust Region Reflective) is motivated by the process of
solving a system of equations, which constitute the first-order optimality
condition for a bound-constrained minimization problem as formulated in
<a class="reference internal" href="#r20fc1df64af7-stir" id="id7">[STIR]</a>. The algorithm iteratively solves trust-region subproblems
augmented by a special diagonal quadratic term and with trust-region shape
determined by the distance from the bounds and the direction of the
gradient. This enhancements help to avoid making steps directly into bounds
and efficiently explore the whole space of variables. To further improve
convergence, the algorithm considers search directions reflected from the
bounds. To obey theoretical requirements, the algorithm keeps iterates
strictly feasible. With dense Jacobians trust-region subproblems are
solved by an exact method very similar to the one described in <a class="reference internal" href="#r20fc1df64af7-jjmore" id="id8">[JJMore]</a>
(and implemented in MINPACK). The difference from the MINPACK
implementation is that a singular value decomposition of a Jacobian
matrix is done once per iteration, instead of a QR decomposition and series
of Givens rotation eliminations. For large sparse Jacobians a 2-D subspace
approach of solving trust-region subproblems is used <a class="reference internal" href="#r20fc1df64af7-stir" id="id9">[STIR]</a>, <a class="reference internal" href="#r20fc1df64af7-byrd" id="id10">[Byrd]</a>.
The subspace is spanned by a scaled gradient and an approximate
Gauss-Newton solution delivered by <a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a>. When no
constraints are imposed the algorithm is very similar to MINPACK and has
generally comparable performance. The algorithm works quite robust in
unbounded and bounded problems, thus it is chosen as a default algorithm.</p>
<p>Method ‘dogbox’ operates in a trust-region framework, but considers
rectangular trust regions as opposed to conventional ellipsoids <a class="reference internal" href="#r20fc1df64af7-voglis" id="id11">[Voglis]</a>.
The intersection of a current trust region and initial bounds is again
rectangular, so on each iteration a quadratic minimization problem subject
to bound constraints is solved approximately by Powell’s dogleg method
<a class="reference internal" href="#r20fc1df64af7-numopt" id="id12">[NumOpt]</a>. The required Gauss-Newton step can be computed exactly for
dense Jacobians or approximately by <a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a> for large
sparse Jacobians. The algorithm is likely to exhibit slow convergence when
the rank of Jacobian is less than the number of variables. The algorithm
often outperforms ‘trf’ in bounded problems with a small number of
variables.</p>
<p>Robust loss functions are implemented as described in <a class="reference internal" href="#r20fc1df64af7-ba" id="id13">[BA]</a>. The idea
is to modify a residual vector and a Jacobian matrix on each iteration
such that computed gradient and Gauss-Newton Hessian approximation match
the true gradient and Hessian approximation of the cost function. Then
the algorithm proceeds in a normal way, i.e., robust loss functions are
implemented as a simple wrapper over standard least-squares algorithms.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17.0.</span></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r20fc1df64af7-stir"><span class="brackets">STIR</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id7">2</a>,<a href="#id9">3</a>)</span></dt>
<dd><p>M. A. Branch, T. F. Coleman, and Y. Li, “A Subspace, Interior,
and Conjugate Gradient Method for Large-Scale Bound-Constrained
Minimization Problems,” SIAM Journal on Scientific Computing,
Vol. 21, Number 1, pp 1-23, 1999.</p>
</dd>
<dt class="label" id="r20fc1df64af7-nr"><span class="brackets"><a class="fn-backref" href="#id3">NR</a></span></dt>
<dd><p>William H. Press et. al., “Numerical Recipes. The Art of Scientific
Computing. 3rd edition”, Sec. 5.7.</p>
</dd>
<dt class="label" id="r20fc1df64af7-byrd"><span class="brackets">Byrd</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>R. H. Byrd, R. B. Schnabel and G. A. Shultz, “Approximate
solution of the trust region problem by minimization over
two-dimensional subspaces”, Math. Programming, 40, pp. 247-263,
1988.</p>
</dd>
<dt class="label" id="r20fc1df64af7-curtis"><span class="brackets"><a class="fn-backref" href="#id5">Curtis</a></span></dt>
<dd><p>A. Curtis, M. J. D. Powell, and J. Reid, “On the estimation of
sparse Jacobian matrices”, Journal of the Institute of
Mathematics and its Applications, 13, pp. 117-120, 1974.</p>
</dd>
<dt class="label" id="r20fc1df64af7-jjmore"><span class="brackets">JJMore</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id6">2</a>,<a href="#id8">3</a>)</span></dt>
<dd><p>J. J. More, “The Levenberg-Marquardt Algorithm: Implementation
and Theory,” Numerical Analysis, ed. G. A. Watson, Lecture
Notes in Mathematics 630, Springer Verlag, pp. 105-116, 1977.</p>
</dd>
<dt class="label" id="r20fc1df64af7-voglis"><span class="brackets"><a class="fn-backref" href="#id11">Voglis</a></span></dt>
<dd><p>C. Voglis and I. E. Lagaris, “A Rectangular Trust Region
Dogleg Approach for Unconstrained and Bound Constrained
Nonlinear Optimization”, WSEAS International Conference on
Applied Mathematics, Corfu, Greece, 2004.</p>
</dd>
<dt class="label" id="r20fc1df64af7-numopt"><span class="brackets"><a class="fn-backref" href="#id12">NumOpt</a></span></dt>
<dd><p>J. Nocedal and S. J. Wright, “Numerical optimization,
2nd edition”, Chapter 4.</p>
</dd>
<dt class="label" id="r20fc1df64af7-ba"><span class="brackets"><a class="fn-backref" href="#id13">BA</a></span></dt>
<dd><p>B. Triggs et. al., “Bundle Adjustment - A Modern Synthesis”,
Proceedings of the International Workshop on Vision Algorithms:
Theory and Practice, pp. 298-372, 1999.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In this example we find a minimum of the Rosenbrock function without bounds
on independent variables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun_rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
</pre></div>
</div>
<p>Notice that we only provide the vector of the residuals. The algorithm
constructs the cost function as a sum of squares of the residuals, which
gives the Rosenbrock function. The exact minimum is at <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[1.0,</span> <span class="pre">1.0]</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_rosenbrock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_rosenbrock</span><span class="p">,</span> <span class="n">x0_rosenbrock</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">cost</span>
<span class="go">9.8669242910846867e-30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">8.8928864934219529e-14</span>
</pre></div>
</div>
<p>We now constrain the variables, in such a way that the previous solution
becomes infeasible. Specifically, we require that <code class="docutils literal notranslate"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">1.5</span></code>, and
<code class="docutils literal notranslate"><span class="pre">x[0]</span></code> left unconstrained. To this end, we specify the <em class="xref py py-obj">bounds</em> parameter
to <a class="reference internal" href="#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">least_squares</span></code></a> in the form <code class="docutils literal notranslate"><span class="pre">bounds=([-np.inf,</span> <span class="pre">1.5],</span> <span class="pre">np.inf)</span></code>.</p>
<p>We also provide the analytic Jacobian:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">jac_rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>        <span class="p">[</span><span class="o">-</span><span class="mi">20</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Putting this all together, we see that the new solution lies on the bound:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_rosenbrock</span><span class="p">,</span> <span class="n">x0_rosenbrock</span><span class="p">,</span> <span class="n">jac_rosenbrock</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.22437075,  1.5       ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">cost</span>
<span class="go">0.025213093946805685</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">1.5885401433157753e-07</span>
</pre></div>
</div>
<p>Now we solve a system of equations (i.e., the cost function should be zero
at a minimum) for a Broyden tridiagonal vector-valued function of 100000
variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun_broyden</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">f</span>
</pre></div>
</div>
<p>The corresponding Jacobian matrix is sparse. We tell the algorithm to
estimate it by finite differences and provide the sparsity structure of
Jacobian to significantly speed up this process.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">lil_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sparsity_broyden</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sparsity</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">sparsity</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_broyden</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_broyden</span><span class="p">,</span> <span class="n">x0_broyden</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">jac_sparsity</span><span class="o">=</span><span class="n">sparsity_broyden</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span><span class="o">.</span><span class="n">cost</span>
<span class="go">4.5687069299604613e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">1.1650454296851518e-11</span>
</pre></div>
</div>
<p>Let’s also solve a curve fitting problem using robust loss function to
take care of outliers in the data. Define the model function as
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">exp(c</span> <span class="pre">*</span> <span class="pre">t)</span></code>, where t is a predictor variable, y is an
observation and a, b, c are parameters to estimate.</p>
<p>First, define the function which generates the data with noise and
outliers, define the model parameters, and generate data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_outliers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">rnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">error</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">rnd</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">outliers</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n_outliers</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">error</span><span class="p">[</span><span class="n">outliers</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">10</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">y</span> <span class="o">+</span> <span class="n">error</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_points</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">n_outliers</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Define function for computing residuals and initial estimate of
parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
</pre></div>
</div>
<p>Compute a standard least-squares solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_lsq</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
</pre></div>
</div>
<p>Now compute two solutions with two different robust loss functions. The
parameter <em class="xref py py-obj">f_scale</em> is set to 0.1, meaning that inlier residuals should
not significantly exceed 0.1 (the noise level used).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_soft_l1</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;soft_l1&#39;</span><span class="p">,</span> <span class="n">f_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_log</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;cauchy&#39;</span><span class="p">,</span> <span class="n">f_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
</pre></div>
</div>
<p>And, finally, plot all the curves. We see that by selecting an appropriate
<em class="xref py py-obj">loss</em>  we can get estimates close to optimal even in the presence of
strong outliers. But keep in mind that generally it is recommended to try
‘soft_l1’ or ‘huber’ losses first (if at all necessary) as the other two
options may cause difficulties in optimization process.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_lsq</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_lsq</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_soft_l1</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_soft_l1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_log</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_log</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_lsq</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;linear loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_soft_l1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;soft_l1 loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_log</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cauchy loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="../_images/scipy-optimize-least_squares-1_00_00.png" src="../_images/scipy-optimize-least_squares-1_00_00.png" />
</div>
<p>In the next example, we show how complex-valued residual functions of
complex variables can be optimized with <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code>. Consider the
following function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>We wrap it into a function of real variables that returns real residuals
by simply handling the real and imaginary parts as independent variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f_wrap</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">fx</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fx</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">imag</span><span class="p">])</span>
</pre></div>
</div>
<p>Thus, instead of the original m-D complex function of n complex
variables we optimize a 2m-D real function of 2n real variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_wrapped</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f_wrap</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">res_wrapped</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">res_wrapped</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">(0.49999999999925893+0.49999999999925893j)</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.optimize.dual_annealing.html"
                        title="previous chapter">scipy.optimize.dual_annealing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.optimize.nnls.html"
                        title="next chapter">scipy.optimize.nnls</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on Dec 16, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.3.0.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>